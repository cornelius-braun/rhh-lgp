## Syntactic keywords
QUIT
INFEASIBLE
ANY
Terminate

FOL_World{
  hasWait=false
  gamma = 1.
  stepCost = 0.
  timeCost = 0.
}

## activities

## basic predicates
gripper
support
base
tray
grippable
object
target
mobile
onMobile
lWalker
rWalker

# dynamic
connected
linked
on
busy     # involved in an ongoing (durative) activity
grasped
held
equal
placed
touched

## KOMO symbols
above
touch
stable
stableOn
connectCrawlers
touchBoxNormalX

## constants (added by the code)


## initial state (generated by the code)
START_STATE {}

### RULES
#####################################################################

#termination rule
#Rule {
#  { (on banana tray) }
#  { (QUIT) }
#}

### Reward
REWARD {
#  tree{
#    leaf{ { (grasped handR screwdriverHandle) }, r=10. }
#    weight=1.
#  }
}


#####################################################################
# This gives info about grippers that are part of the same walker
Rule {
  A, B
  { (lWalker A) (lWalker B) (equal A B)! }
  { (linked A B) }
}

Rule {
  A, B
  { (rWalker A) (rWalker B) (equal A B)! }
  { (linked A B) }
}

# linked is symmetrical
Rule {
  A, B
  { (linked A B) }
  { (linked B A) }
}

#####################################################################
# the linked predicate makes sure that we do not try to grasp ourselves
# B is the other end of the chain
# if something complains it is because I removed the object here
DecisionRule grasp {
  A, X
  { (gripper A) (busy A)! (support A)!
    (object X) (gripper X)! (grippable X) (held X)! (touched A X)! #(placed X)! # oz: added 'base' frame as a logical 'base' in scene.g
    (INFEASIBLE grasp A X)! }
  { (busy A)
    (held X) (grasped A X) (stable ANY X)! (touched A X) komo(above X ANY)!
    komo(touch ANY X)! #(stableOn ANY X)!
    komo(stable A X) komo(touch A X) #(stable ANY X)!
  }
}

#####################################################################
# walk from A standing on X to B standing on Y
DecisionRule step {
  A, B, X, Y
  { (gripper A) (support A) (busy A)
    (gripper B) (support B)! (busy B)!
    (linked A B) (connected A B)!
    (object X) (base X) (on X A) (grippable X)!
    (object Y) (base Y) (grippable Y)!
    (INFEASIBLE step A B X Y)!  }
  { (busy A)! (support A)! (stable ANY A)! (on X A)! (touch A X)!
    (busy B) (support B) (stable Y B) komo(touch Y B) (on Y B)
  }
}

#####################################################################
# before: A is support, B is free. D is support, C is free
# after: D is support, B and C are connected and A is free
DecisionRule connect {
  A, B, C, D
  { (gripper A) (support A) (busy A) (onMobile A)!
    (gripper B) (support B)! (busy B)!
    (linked A B)
    (gripper C) (support C)! (busy C)!
    (gripper D) (support D) (busy D)
    (linked C D)
    (equal B C)! (equal A D)!
    (INFEASIBLE connect A B C D)! }
  { (busy A)! (support A)! (stable ANY A)! (on ANY A)!
    (busy B)
    (busy C)
    (connected B C) (connected C B)
    (stable C B) komo(connectCrawlers C B)
  }
}

#####################################################################
DecisionRule place {
  X, Y, Z
  { (gripper X) (grasped X Y) (tray Z) (held Y) (INFEASIBLE place X Y Z)! }
  { (grasped X Y)! (busy X)! (busy Y)! (held Y)! (placed Y) (on Z Y)  # logic only
    komo(stable Y ANY)!     # NLP predicates
    komo(touch X Y)! komo(touch Y Z) komo(above Y Z)
    komo(stable Z Y) komo(stable X Y)!
    }
}

#####################################################################
# pre: B and C are connected and the walker is standing on D
# post: B and C are not connected anymore, walker1 is standing on A and walker2 is standing on D
# for simplicity we can only disconnect onto the object that D is already standing on
DecisionRule disconnect {
  A, B, C, D, X
  { (gripper A) (support A)! (busy A)!
    (busy B)
    (busy C)
    (linked A B) (equal A B)! (linked C D) (equal C D)!
    (connected B C)
    (gripper D) (support D) (on X D)
    (INFEASIBLE disconnect A B C D X)! }
  { (support A) (busy A) (stable X A) komo(touch X A) (on X A)
    (busy B)! (support B)! (stable ANY B)!
    (busy C)! (support C)! (stable C ANY)!
    (stable B C)!
    (connected B C)! (connected C B)!
    komo(connectCrawlers B C)! komo(connectCrawlers C B)!
    komo(touch B C)! komo(touch B C)!
  }
}

#####################################################################
# connect to base from standing on X
DecisionRule connect2mobile {
  A, B, X, Y
  { (gripper A) (support A) (busy A)
    (gripper B) (support B)! (stable ANY B)! (busy B)!
    (linked A B) (connected A B)!
    (object X) (gripper X)! (on X A)
    (object Y) (mobile Y) (busy Y)! (on X Y)
    (INFEASIBLE connect2mobile A B X Y)!  }
  { (stable ANY A)! (busy A)! (support A)! (on X A)!
    (touchBoxNormalX B Y)
    (busy B) (support B) (stable Y B) (on Y B) (busy Y) (onMobile B)
  }
}

#####################################################################
# in the beginning A is support, B and C are connected and D is free
# after step: D is support, B and C are still connected and A is free
DecisionRule steptogether {
  A, B, C, D, X, Y
  { (gripper A) (support A) (busy A)
    (gripper B) (support B)! (busy B)
    (gripper C) (support C)! (busy C)
    (gripper D) (support D)! (busy D)!
    (connected B C) (linked A B) (linked C D)
    (object X) (grippable X)! (object Y) (grippable Y)! (on X A) (base X) (base Y)
    (INFEASIBLE steptogether A B C D X Y)! }
  { (busy A)! (support A)! (stable ANY A)! (on X A)!
    (busy D) (support D) (stable Y D) komo(touch Y D) (on Y D)
    (stable B ANY)!
    (stable ANY C)!
    komo(touch C B) (stable C B)
  }
}

